#pragma config(Sensor, S2,     sound,               sensorSoundDB)
#pragma config(Sensor, S3,     sonar,               sensorSONAR)
#pragma config(Motor,  motorA,          ,              tmotorNormal, PIDControl, reversed)
#pragma config(Motor,  motorB,          ,              tmotorNormal, PIDControl, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*===================================================================================
                              Global Variables
/*===================================================================================*/
const int SPEED = 40;
const int RDEGREE = 150;


#define unexplored 99
typedef enum {cheese, home, empty} cellthing;
typedef enum {gap, wall, vwall} wall_state;
typedef enum {unvisited,visited} visit_state;
typedef enum {north, south , east , west} direction;

typedef struct {
  int vc;
  cellthing smell;
  wall_state n_wall;
  wall_state e_wall;
  wall_state s_wall;
  wall_state w_wall;
  visit_state visit;
  direction entrance;
 } cell;


cell maze[4][6];
direction robot_facing;


// Home Location
const int homex = 0;
const int homey = 0;


// Cheese Location
const int cheesex = 3;
const int cheesey = 5;


// position coordinates
int i;
int j;


//Function Declarations
void turn_right();
void turn_left();
void turn_180();
void move_fwd ();
void move_back();
void move_to_wall();
void align();
void decide();
void explore();
void orient(direction go2);
void GoHome();


task main(){


  i = homex;
  j = homey;


 wait10Msec(50);
 //wait for the whistle
 while( SensorValue [sound] < 90){
 }


 //initialization
 for (int k=0;k<4;k++){
      for (int l=0;l<6;l++){
        maze[k][l].visit = unvisited;
        maze[k][l].n_wall=unexplored;
        maze[k][l].e_wall=unexplored;
        maze[k][l].w_wall=unexplored;
        maze[k][l].s_wall=unexplored;
        maze[k][l].entrance = south;
        }
    }


//start moving
  do {
    do{


      explore();


      if(maze[i][j].n_wall==gap) nxtDisplayCenteredTextLine(3,"N=gap");
      else if(maze[i][j].n_wall==wall) nxtDisplayCenteredTextLine(3,"N=Wall");


      if(maze[i][j].e_wall==gap) nxtDisplayCenteredTextLine(4,"E=gap");
      else if(maze[i][j].e_wall==wall) nxtDisplayCenteredTextLine(4,"E=Wall");


      if(maze[i][j].s_wall==gap) nxtDisplayCenteredTextLine(5,"S=gap");
      else if(maze[i][j].s_wall==wall) nxtDisplayCenteredTextLine(5,"S=Wall");


      if(maze[i][j].w_wall==gap) nxtDisplayCenteredTextLine(6,"W=gap");
      else if(maze[i][j].w_wall==wall) nxtDisplayCenteredTextLine(6,"W=Wall");


  align();
  decide();
  orient(north);
  wait10Msec(20);
}
  while(i!=cheesex);
}
  while(j!=cheesey);


  //****** Found the Cheese*****
  PlaySound(soundUpwardTones);
  wait10Msec(100);


  //Go Back Home
  do{
    do{


  GoHome();
    }
  while(i!=homex);
      }
    while(j!=homey);
  //******Got Home******//
  PlaySound(soundDownwardTones);
  wait10Msec(100);
}
 //**************************************************************
 //**************************Explore******************************
 //****************************************************************
void explore (){


  //explore if you have'nt visited that cell
  if (maze[i][j].visit == unvisited) {


    // Scan North
    if(maze[i][j].n_wall == unexplored){
     if(SensorValue[sonar]<20) maze[i][j].n_wall = wall;
     else maze[i][j].n_wall = gap;
   }
   turn_right();


  // Scan East
  if(maze[i][j].e_wall == unexplored){
    if(SensorValue[sonar]<20){
    maze[i][j].e_wall = wall;
    //Alignment
    move_to_wall();
    wait10Msec(20);
    move_back();
    wait10Msec(20);
 }
    else maze[i][j].e_wall = gap;
  }
  turn_right();


  // Scan South
  if(maze[i][j].s_wall == unexplored){
    if(SensorValue[sonar]<20) maze[i][j].s_wall = wall;
      else maze[i][j].s_wall = gap;
  }
  turn_right();


  // Scan West
  if(maze[i][j].w_wall == unexplored){
    if(SensorValue[sonar]<20) {maze[i][j].w_wall = wall;
   //Alignment
    move_to_wall();
    wait10Msec(20);
    move_back();
    wait10Msec(20);
 }
    else maze[i][j].w_wall = gap;
  }
  turn_right();
}
}


void move_east(){
   orient(east);
   move_fwd();
   i++;
 }
void move_west(){
   orient(west);
   move_fwd();
   i--;
 }
void move_south(){
   orient(south);
   move_fwd();
   j--;
 }
void move_north(){
   orient(north);
   move_fwd();
   j++;
 }


 //***************************************************************
 //**************************Decide********************************
 //****************************************************************

void decide (){
    maze[i][j].visit=visited;

//****If the next cell hasn't been visited****
//****and there a gap in the current cell*****
//****go to the next cel**********************

    if( (maze[i][j].n_wall == gap) && (maze[i][j+1].visit == unvisited) ){
      move_north();
      maze[i][j].entrance = south;
      return;
    }
    if( (maze[i][j].e_wall == gap) && (maze[i+1][j].visit == unvisited) ) {
      move_east();
      maze[i][j].entrance = west;
      return;
    }
    if( (maze[i][j].s_wall == gap) && (maze[i][j-1].visit == unvisited) ) {
      move_south();
      maze[i][j].entrance = north;
      return;
    }
    if( (maze[i][j].w_wall == gap) && (maze[i-1][j].visit == unvisited) ) {
      move_west();
      maze[i][j].entrance = east;
      return;
    }


   if( maze[i][j].entrance == north ) {
      move_north();
      return;
   }
   if( maze[i][j].entrance == east ) {
      move_east();
      return;
   }
   if( maze[i][j].entrance == south ) {
      move_south();
      return;
   }
   if( maze[i][j].entrance == west ) {
      move_west();
      return;
   }
}


void move_fwd (){
 nSyncedMotors               = synchAB;   // "A" will be synchronized to "B".
 nSyncedTurnRatio         = 100;       // straight line
    nMotorEncoderTarget[motorA]    = 570;       // incremental amount to move motor -- one revolution
    motor[motorA]               = -SPEED;    // motor speed
    while (nMotorRunState[motorA] != runStateIdle)
    {}
}
void move_to_wall (){
   nSyncedMotors             = synchAB;
   motor[motorA]                  = -SPEED;
   wait10Msec(100);
  }


void move_back(){
    nSyncedMotors              = synchAB;   // "A" will be synchronized to "B".
 nSyncedTurnRatio          = 100;       // straight line
    nMotorEncoderTarget[motorA]    = 140;       // incremental amount to move motor -- one revolution***CHECK
    motor[motorA]               = 40 ;        // motor speed
    while (nMotorRunState[motorA] != runStateIdle)
    {}
   wait10Msec(10);
}


void turn_right(){
    nSyncedMotors             = synchAB;   // "A" will be synchronized to "B".
    nSyncedTurnRatio         = -100;      // straight line
    nMotorEncoderTarget[motorA]    = RDEGREE ;  // incremental amount to move motor -- one revolution
    motor[motorA]               = SPEED;     // motor speed
    while (nMotorRunState[motorA] != runStateIdle)
    {};

    if(robot_facing==north) robot_facing=east;
    else if (robot_facing==east) robot_facing=south;
    else if (robot_facing==south) robot_facing=west;
    else if (robot_facing==west) robot_facing=north;
}


void turn_left(){
    nSyncedMotors              = synchAB;   // "A" will be synchronized to "B".
    nSyncedTurnRatio         = -100;      // straight line
    nMotorEncoderTarget[motorA]    = -RDEGREE ; // incremental amount to move motor -- one revolution
    motor[motorA]               = -SPEED;    // motor speed
    while (nMotorRunState[motorA] != runStateIdle)
    {}


    if(robot_facing==north) robot_facing=west;
    else if (robot_facing==east) robot_facing=north;
    else if (robot_facing==south) robot_facing=east;
    else if (robot_facing==west) robot_facing= south ;
}


void turn_180(){
   nSyncedMotors             = synchAB;   // "A" will be synchronized to "B".
 nSyncedTurnRatio         = -100;      // straight line
    nMotorEncoderTarget[motorA]  = 2*RDEGREE; // incremental amount to move motor -- one revolution
    motor[motorA]               = SPEED;     // motor speed
    while (nMotorRunState[motorA] != runStateIdle)
    {}


    if(robot_facing==north) robot_facing=south;
    else if (robot_facing==east) robot_facing=west;
    else if (robot_facing==south) robot_facing=north;
    else if (robot_facing==west) robot_facing= east ;
}


void orient (direction go2){


  if( ( robot_facing==north) && (go2==east) )
  turn_right();
   else if( ( robot_facing==north) && (go2==west) )
    turn_left();
   else if( ( robot_facing==north) && (go2==south) ) turn_180();


  if( ( robot_facing==east) && (go2==north) ) turn_left();
   else if( ( robot_facing==east) && (go2==west) ) turn_180();
   else if( ( robot_facing==east) && (go2==south) ) turn_right();


  if( ( robot_facing==west) && (go2==north) ) turn_right();
   else if( ( robot_facing==west) && (go2==east) ) turn_180();
   else if( ( robot_facing==west) && (go2==south) ) turn_left();


  if( ( robot_facing==south) && (go2==east) ) turn_left();
   else if( ( robot_facing==south) && (go2==west) ) turn_right();
   else if( ( robot_facing==south) && (go2==north) ) turn_180();
}


void GoHome(){


  if( (maze[i][j].entrance == north) && (maze[i][j+1].visit == visited) ){
      move_north();
      align();
      return;
    }
  if( (maze[i][j].entrance == east) && (maze[i+1][j].visit == visited) ) {
      move_east();
      align();
      return;
    }
  if( (maze[i][j].entrance == south) && (maze[i][j-1].visit == visited) ) {
      move_south();
      return;
    }
  if( (maze[i][j].entrance == west) && (maze[i-1][j].visit == visited) ) {
      move_west();
      return;
    }
}


void align(){
   if ( (SensorValue[sonar] < 20) && (maze[i][j].n_wall == wall)){
   move_to_wall();
   wait10Msec(30);
   move_back();
   wait10Msec(30);
 }
   else if((SensorValue[sonar] < 20) && (maze[i][j].w_wall == wall)){
   move_to_wall();
   wait10Msec(30);
   move_back();
   wait10Msec(30);


   }
}
