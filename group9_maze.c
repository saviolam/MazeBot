#pragma config(Sensor, S2,     sound,               sensorSoundDB)
#pragma config(Sensor, S3,     eyes,                sensorSONAR)
#pragma config(Motor,  motorA,          ,              tmotorNormal, PIDControl, )
#pragma config(Motor,  motorB,          ,              tmotorNormal, PIDControl, )
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
________________________________________________________________________________________
*/


void goForward();

void turnLeft();

void turnRight();

bool checkForWall();

void scanning();

void followLeftWall();

void followRightWall();

void changeDirection();

void updateWalls(bool wall);

int countOpen(int n, int m);

void i_j();

void detectBadCell(int n, int m);

void fixErrors();

void fixStraightErrors();



struct
{

	bool nwall;

	bool swall;

	bool ewall;

	bool wwall;

	int visited;

	int open;

	bool bad;

}cell;



cell Maze[6][4];

int start_x = 0;

int start_y = 0;

int destin_x = 0;

int destin_y = 1;

int i = start_x;

int j = start_y;



bool forward;

bool right;

bool left;

bool backward;

int dir = 1; // 1=west,2=north,3=east,4=south

int count = 0;

bool checkBad = false;

bool finish = false;

int walls = 0;

/*
___________________________________MAIN TASK_________________________________________
*/



task display()
{

	while(true){

		nxtDisplayCenteredTextLine(3,"i = %d",i);

		nxtDisplayCenteredTextLine(4,"j = %d",j);

		wait10Msec(10);

	}

}



task main()
{

	wait10Msec(100);
	while(SensorValue[sound] < 70){
	}

	StartTask(display);

	for (int k = 0; k < 6; k++)
	{
		for (int l = 0; l < 4; l++)
		{

			Maze[k][l].visited = 0;

			Maze[k][l].bad = false;

			Maze[k][l].wwall = true; // false means there is a wall

			Maze[k][l].nwall = true;

			Maze[k][l].ewall = true;

			Maze[k][l].swall = true;
		}
	}


	for (int k = 0; k < 6; k++)
	{

		Maze[k][0].ewall = false;

		Maze[k][3].wwall = false;

	}



	for (int l = 0; l < 4; l++)
	{

		Maze[5][l].nwall = false;

		Maze[0][l].swall = false;

	}

	while (!finish)
	{

		scanning();

		if (!left && !forward)
		{

			fixErrors();

		}
		else if (!right && !forward)
		{

			fixErrors();

		}
		else if (count == 2)
		{

			fixStraightErrors();

			count = 0;

		}

		followLeftWall();

		goForward();

		i_j();


		if (i == destin_x)
		{
			if (j == destin_y)
			{

				finish = true;

				PlaySound(soundUpwardTones);

			}

		}

	}



	destin_x = start_x;

	destin_y = start_y;

	start_x = i;

	start_y = j;

	finish = false;

	turnLeft();

	turnLeft();



	if (walls > 25)
	{

		while (!finish)
		{

			scanning();

			if (!left && !forward)

			fixErrors();

			else if (!right && !forward)

			fixErrors();

			else if (count == 2)
			{

				fixStraightErrors();

				count = 0;

			}

			followLeftWall();

			goForward();

			i_j();

			if (i == destin_x)
			{

				if (j == destin_y)
				{

					finish = true;

					PlaySound(soundUpwardTones);

				}
			}

		}

	}

	else
	{

		while (!finish)
		{

			scanning();

			if (!left && !forward)

			fixErrors();

			else if (!right && !forward)

			fixErrors();

			else if (count == 2)
			{

				fixStraightErrors();

				count = 0;

			}

			followRightWall();

			goForward();

			i_j();

			if (i == destin_x)
			{

				if (j == destin_y)
				{

					finish = true;

					PlaySound(soundUpwardTones);
				}
			}

		}
	}


/*
	for (int k = 0; k < 6; k++)
	{
		for (int l = 0; l < 4; l++)
		{

			//Maze[k][l].open = countOpen(k, l);

			int count1 = 0;

			if (Maze[k][l].ewall == true)
			{

				count1++;

			}

			if (Maze[k][l].nwall == true)
			{

				count1++;

			}

			if (Maze[k][l].wwall == true)
			{

				count1++;

			}

			if (Maze[k][l].swall == true)
			{

				count1++;

			}

			Maze[k][l].open = count1;

			detectBadCell(k, l);

		}

	}
*/

}

/*

____________________________________FUNCTIONS________________________________________

*/

void goForward()
{

	nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorA] < 480)
	{

		motor[motorA] = 10; //turn both motors on at 50 percent power

		motor[motorB] = 10;

	}

	motor[motorA] = 0; //turn both motors on at 50 percent power

	motor[motorB] = 0;

	wait10Msec(10);

}



void turnLeft()
{

	nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorA] < 101)
	{

		motor[motorA] = 10; //turn both motors on at 50 percent power

		motor[motorB] = -10;

	}


	motor[motorA] = 0; //turn both motors on at 50 percent power

	motor[motorB] = 0;

	wait10Msec(10);

	changeDirection();

	changeDirection();

	changeDirection();

}



void turnRight()
{

	nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorB] < 101)
	{

		motor[motorA] = -10; //turn both motors on at 50 percent power

		motor[motorB] = 10;

	}

	motor[motorA] = 0; //turn both motors on at 50 percent power

	motor[motorB] = 0;

	wait10Msec(10);

	changeDirection();

}



bool checkForWall()
{

	if (SensorValue[eyes] < 20)

	return false;

	else

	return true;

}



void scanning()
{

	forward = false;

	left = false;

	backward = false;

	right = false;

	if (checkForWall())
	{

		left = true;

	}

	else
	{

		left = false;

		updateWalls(left);

		turnRight();
	}

	if (checkForWall())
	{

		forward = true;

	}

	else
	{

		forward = false;

	}

	updateWalls(forward);

	turnRight();

	if (checkForWall())
	{

		right = true;

	}

	else
	{

		right = false;

	}

	updateWalls(right);

	if (!left && !right && !forward)
	{

		backward = true;

		//Maze[i][j].bad = true;

		//checkBad = true;

	}

	turnLeft();

	turnLeft();

	Maze[i][j].visited++;

	//Maze[i][j].open = countOpen();

}



void followLeftWall()
{

	if (left)
	{

		turnLeft();

		count = 0;

		return;
	}

	if (forward)
	{

		count++;

		walls++;

		return;
	}

	if (right)
	{

		turnRight();

		count = 0;

		walls++;

		walls++;

		return;
	}

	if (backward)
	{

		turnLeft();

		turnLeft();

		fixStraightErrors();

		count = 0;

		walls++;

		walls++;

		walls++;

		return;

	}

}



void followRightWall()
{

	if (right)
	{

		turnRight();

		count = 0;

		return;
	}

	if (forward)
	{

		count++;

		return;
	}

	if (left)
	{

		turnLeft();

		count = 0;

		return;
	}

	if (backward)
	{

		turnLeft();

		turnLeft();

		fixStraightErrors();

		count = 0;

		return;
	}

}



void changeDirection()
{

	if (dir < 4)

	dir++;

	else if (dir == 4)

	dir = 1;

}


/*
int countOpen(int n, int m)
{

	int count1 = 0;

	if (Maze[n][m].ewall)
	{

		count1++;

	}

	if (Maze[n][m].nwall)
	{

		count1++;

	}

	if (Maze[n][m].wwall)
	{

		count1++;

	}

	if (Maze[n][m].swall)
	{

		count1++;

	}

	return count1;

}
*/

void i_j()
{

	if (dir == 1)
	{
		j++;
	}

	if (dir == 2)
	{
		i++;
	}

	if (dir == 3)
	{
		j--;
	}

	if (dir == 4)
	{
		i--;
	}

}



void updateWalls(bool wall)
{

	if (dir == 1)
	{

		Maze[i][j].swall = wall;

	}

	else if (dir == 2)
	{

		Maze[i][j].wwall = wall;

	}

	else if (dir == 3)
	{

		Maze[i][j].nwall = wall;

	}

	else if (dir == 4)
	{

		Maze[i][j].ewall = wall;

	}

}



void detectBadCell(int n, int m)
{

	if (Maze[n][m].open == 1)
	{

		Maze[n][m].bad = true;

	}

	else if (Maze[n][m].open == 2)
	{

		if (n > 0)
		{
			if (Maze[n-1][m].bad)
			{

				Maze[n][m].bad = true;

			}

		}

		if (n < 5)
		{
			if (Maze[n+1][m].bad)
			{

				Maze[n][m].bad = true;

			}
		}

		if (m > 0)
		{
			if (Maze[n][m-1].bad)
			{

				Maze[n][m].bad = true;

			}
		}

		if (m < 3)
		{
			if (Maze[n][m+1].bad)
			{

				Maze[n][m].bad = true;

			}

		}

	}

	else if (Maze[n][m].open == 3)
	{

	}

}



void fixErrors()
{

	fixStraightErrors();

	nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorA] < 300)
	{

		motor[motorA] = 10; //turn both motors on at 50 percent power

		motor[motorB] = 10;

	}

	motor[motorA] = 0; //turn both motors on at 50 percent power

	motor[motorB] = 0;

	wait10Msec(10);

	nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorA] > -101)
	{

		motor[motorA] = -10; //turn both motors on at 50 percent power

		motor[motorB] = -10;

	}

	motor[motorA] = 0; //turn both motors on at 50 percent power

	motor[motorB] = 0;

	wait10Msec(10);

}



void fixStraightErrors()
{

	if (!right)
	{

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorB] < 101)
		{

			motor[motorA] = -10; //turn both motors on at 50 percent power

			motor[motorB] = 10;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorA] < 300)
		{

			motor[motorA] = 20; //turn both motors on at 50 percent power

			motor[motorB] = 20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorA] > -101)
		{

			motor[motorA] = -20; //turn both motors on at 50 percent power

			motor[motorB] = -20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorA] < 101)
		{

			motor[motorA] = 20; //turn both motors on at 50 percent power

			motor[motorB] = -20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

	}

	else if (!left)
	{

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorA] < 101)
		{

			motor[motorA] = 20; //turn both motors on at 50 percent power

			motor[motorB] = -20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorA] < 300)
		{

			motor[motorA] = 20; //turn both motors on at 50 percent power

			motor[motorB] = 20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorA] > -101)
		{

			motor[motorA] = -20; //turn both motors on at 50 percent power

			motor[motorB] = -20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

		nMotorEncoder[motorA] = 0; //clear the LEGO encoders in motors B and C+

		nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorB] < 101)
		{

			motor[motorA] = -20; //turn both motors on at 50 percent power

			motor[motorB] = 20;

		}

		motor[motorA] = 0; //turn both motors on at 50 percent power

		motor[motorB] = 0;

		wait10Msec(10);

	}

}



/*
void shortestRoute(int n, int m)
{

	check cells with visited= 1

	follow through these cells,
	when the only option to enter is visited = 2, enter
	then check for the openings

}
*/
